## Острова
### Основная идея:
* Строим из данного нам массива орграф, где элементы соединены с соседними и все крайние элементы соединены с морем
* Веса рёбер подбираются в зависимости от разницы высот: 2 -> 3 - вес 1, 3 -> 2 - вес 0, потому что нас интересуют только подъёмы воды, спуски можно игнорировать
* Перебираем вершины (высоты) с наименьшего до наибольшего и строим кратчайший путь до "моря" используя алгоритм беллмана-форда (алгоритм я взял откуда то с просторов интернета, не стал писать его сам)
* Когда находится такой, путь, который "набирает воду", то мы строим последовательность высот, вида [1, 3, 2, 3] и считаем сколько она набирает воды (в текущем примере будет 1, считаем, что слева после 1 у нас море, которое 0, а справа условная стена, которая выдержит любую высоту воды, дабы дотянуться до максимально высокой левой стены)
* После этого обновляем высоты графа и повторяем пока не переберём все возможные пути
  
  
## Бесконечная последовательность
### Основная идея:
Алгоритм основывается на идее о том, что всю бесконечную последовательность можно разбить на такие группы чисел: (1-9)(10-99)(100-999)... Каждая группа может содержать в каком то виде наше число A. И мы последовательно проходим по каждой из наших групп, пытаясь найти позицию числа. Самое первое вхождение и даст нам правильный ответ. Идти необходимо максимум до len(A).

### Общий ход работы:
* По длине числа строим последовательности возможных значений, неизвестные числа заменяем звёздочками
* Заменяем звёздочки наиболее подходящими значениями и проверям является ли последовательность возрастающей
* Если да, то находим позицию первого числа последовательности и возвращаем результат, если нет, то строим дальше

### Примеры:

* Ищем A = 141
* [1, 4, 1] - смотрим не возрастающая ли, нет, идём к следующему порядку
* [\*1, 41], [14, 1\*] -> [31, 41], [14, 15] - заменили звёздочки и посмотрели: первое не подходит, второе вполне, выдаём индекс 14 как начало искомой последовательности
* Если бы мы не нашли, то пошли бы дальше и построили: [\*\*1, 41\*], [\*14, 1\*\*], [141] и попытались бы их максимально подходяще заменить на [141, 412], [114, 115], [141]


### Примечания:
* Работает быстро, однако неправильно находит позицию некоторых чисел, содержащих '9'. Например, на промежутке от 1 до 1000 он неправильно определяет 28 чисел, содержащих '9'. С девятками вообще всё нетривиально в этом алгоритме. Всё поправимо, но я не успел доделать
* В некоторых местах получилось очень запутанно, просто потому что несовсем тривиальная логика со звёздочками, возможно можно сделать проще
* Чтобы запустить выполнение нужно ввести числа и нажать enter повторно на пустой строке

  
